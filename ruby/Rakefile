#  File: Rakefile
#
#  This file is part of the Ember Ruby Gem.
#
#  Copyright 2015 Autodesk, Inc. <http://ember.autodesk.com/>
#  
#  Authors:
#  Jason Lefley
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL,
#  BUT WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
#  MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  SEE THE
#  GNU GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <http://www.gnu.org/licenses/>.

require 'bundler/gem_tasks'

TYPE_REGEXES = [
  # For lines like: constexpr const char* KEY = "value";
  /const\s+char\s*\*/,

  # For lines like: constexpr int KEY = value;
  /int/,

  # For lines like: constexpr uint8_t KEY = value;
  /uint8_t/
]

def get_definitions(file_name, type_regex)
  File.readlines(File.expand_path(File.join('../../C++/include', file_name), __FILE__)).map { |line|
    m = line.match(/constexpr\s+#{type_regex}\s*(.+?)\s*=\s*(.+?)\s*;/)
    if m && (key = m[1]) && (value = m[2])
      "  #{key} = #{value}".gsub('"', "'")
    else
      nil
    end
  }.compact
end


def definitions_file
  File.expand_path('../lib/smith/definitions.rb', __FILE__)
end

def generate_definitions
  header_files = %w(Shared.h Build.h)
  buf = ['# This file is generated by the import_definitions rake task', '# DO NOT EDIT', 'module Smith']
  buf.concat(header_files.map { |f| TYPE_REGEXES.map { |r| get_definitions(f, r) } })
  buf << 'end'
  buf.flatten.join("\n") << "\n"
end

desc 'Generate constant definition file using preprocessor definitions from C++ header files'
task :import_definitions do
  if (definitions = generate_definitions) == File.read(definitions_file)
    puts 'Definition file is up to date'
  else
    puts 'Updating definition file'
    begin
      File.write(definitions_file, definitions)
    rescue Errno::EACCES
      abort("#{definition_file} is not writable, ensure write access before continuing")
    end
    puts 'Successfully imported constant definitions'
  end
end

task :check_definitions do
  if generate_definitions != File.read(definitions_file)
    abort('definitions.rb is not up to date. Run "rake import_definitions" before continuing')
  end
end

desc 'Deploy to beaglebone'
task deploy: [:check_definitions, :build] do
  puts "Deploying Smith version #{Smith::VERSION}"

  if Gem.win_platform?
    puts('Unable to run "bundle package" automatically, invoke manually if any new dependencies have been added')
  else
    # Package dependencies into vendor/cache on the localhost
    system '/usr/bin/env RUBYOPT= bundle package --all'
    abort('bundle package failed, aborting') if $?.to_i != 0
  end

  # Set paths
  local_root_dir = File.expand_path('..', __FILE__)
  remote_cache_parent_dir = '/root'
  local_cache_dir = File.join(local_root_dir, 'vendor/cache')
  remote_cache_dir = File.join(remote_cache_parent_dir, File.basename(local_cache_dir))
  gem_file = File.join(local_root_dir, 'pkg', "smith-#{Smith::VERSION}.gem")

  require 'sshkit'
  require 'sshkit/dsl'

  host = SSHKit::Host.new("root@#{ENV['HOST'] || '192.168.7.2'}")
  host.ssh_options = { paranoid: false }
  host.password = 'root'

  on host do
    # Clean
    execute "rm -rf #{remote_cache_dir}"

    # Make sure the target directory exists
    execute "mkdir -p #{remote_cache_parent_dir}"

    # Upload the dependencies
    upload! local_cache_dir, remote_cache_parent_dir, recursive: true

    # Upload the gem
    upload! gem_file, remote_cache_dir

    # Uninstall old versions
    execute 'gem uninstall smith -ax'

    # Install the gem using local copies of dependencies
    within remote_cache_dir do
      options = ['install', File.basename(gem_file)]
      options << '--local'
      options << '--no-rdoc --no-ri'
      execute :gem, options
    end

  end

end

